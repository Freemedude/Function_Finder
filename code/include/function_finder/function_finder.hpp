/*
VERSION
TODO USAGE GUIDE, VERSION NUMBER ETC
*/
#pragma once

#include <cstring>
#include <string>
#include <iostream>
#include <format>
#include <string_view>
#include <unordered_map>

// Pre-decls
struct Argument;
struct Value;
enum class Value_Type;
union Value_Data;



/// <summary>
/// The different types of values. See \ref Value for more details.
/// </summary>
enum class Value_Type
{
	/// <summary>
	/// Represents an unknown value type. Usually an error.
	/// </summary>
	UNKNOWN,
	VOID,
	STRING,
	INTEGER,
	FLOAT,
	DOUBLE,
	BOOLEAN
};

/// <summary>
/// A union with each of the different types of data
/// </summary>
union Value_Data
{
	char string_value[128];
	int int_value;
	float float_value;
	double double_value;
	bool bool_value;
};

/// <summary>
/// Represents a value parsed from a source file. This is implemented in an old-school way, rather 
/// than as \ref std::variant because easy serialization was required.
/// </summary>
struct Value
{
	/// <summary>
	/// The value's type.
	/// </summary>
	Value_Type type;

	/// <summary>
	/// The value's actual value.
	/// </summary>
	Value_Data data;
};

enum class Call_Result_Status
{
	SUCCESS,
	NOT_ENOUGH_ARGUMENTS_ERROR, // Helper value is the index of the failed argument.
	ARGUMENT_PARSING_ERROR // Helper value is the number of PROVIDED arguments. You can see required arguments on the Function_Decl.
	// This could be expanded to include stuff like if the client function threw an exception
};

/// <summary>
/// The return value from calling a function. 
/// </summary>
struct Call_Result
{
	Call_Result_Status status;
	Value value; // Unset if error!
	
	// Error stuff
	std::string error_message; // Empty if no error!
	int error_helper_value; // Helper value. Points to the wrong argument index. and more!
};

/// <summary>
/// Base type for the wrappers generated by this program. It takes a string list to handle parsing. 
/// </summary>
using Function_Wrapper = Call_Result (*)(std::vector<std::string> &args, bool call_client_function);

/// <summary>
/// Contains information parsed on a source code function declaration.
/// </summary>
/// <details>
/// This struct is the core of the tool, it is what is parsed during importing, serialized when 
/// exported, and then again imported via the consumer-facing initialization function.
/// The information stored is meant to enable the consumer to implement great tooling for whatever 
/// they need these commands for.
/// </details>
struct Function_Decl
{
	/// <summary>
	/// The consumer-written function's name
	/// </summary>
	std::string name = "UNSET";

	/// <summary>
	/// The note accompanying the consumer-written function.
	/// </summary>
	std::string note = "";

	/// <summary>
	/// The file the consumer-written function was found in.
	/// </summary>
	std::string file = "UNSET";

	/// <summary>
	/// The line the consumer-written function was found on.
	/// </summary>
	size_t line = 0;

	/// <summary>
	/// A pointer to a generated wrapper function, calls the consumer-written function after 
	/// confirming the inputs are valid.
	/// </summary>
	Function_Wrapper function = nullptr;

	/// <summary>
	/// The return type of the consumer-written function.
	/// </summary>
	Value_Type return_type = Value_Type::UNKNOWN;

	/// <summary>
	/// The list of arguments of the consumer-written function. This includes default-argument 
	/// information
	/// </summary>
	std::vector<Argument> arguments;

	/// <summary>
	/// The number of required arguments.
	/// </summary>
	int num_required_args = -1;

	/// <summary>
	/// The number of optional arguments.
	/// </summary>
	int num_optional_args = -1;

	/// <summary>
	/// Default constructor used for when parsing the function and gradually feeding it fields as 
	/// it is parsed.
	/// </summary>
	Function_Decl() = default;

	/// <summary>
	/// Full-initializer constructor for when the consumer is importing the serialized function.
	/// </summary>
	/// <param name="name">Name of the function.</param>
	/// <param name="function">Function poiter to the wrapper function.</param>
	/// <param name="return_type">Return type of the function.</param>
	/// <param name="num_required_args">Number of required arguments.</param>
	/// <param name="num_optional_args">Number of optional arguments.</param>
	/// <param name="file">The source file the function was found in.</param>
	/// <param name="line">The line the function was found on.</param>
	/// <param name="arguments">The function arguments</param>
	/// <param name="note">The function's notes</param>
	Function_Decl(
		std::string name,
		Function_Wrapper function,
		Value_Type return_type,
		int num_required_args,
		int num_optional_args,
		const std::string &file,
		size_t line,
		std::vector<Argument> arguments,
		const std::string &note)
		: name(name), function(function), return_type(return_type),
		num_required_args(num_required_args), num_optional_args(num_optional_args),
		file(file), line(line), arguments(arguments), note(note)
	{
	}

	bool create_predeclaration = false;
};

/// <summary>
/// Contains information parsed from a function argument
/// </summary>
struct Argument
{
	/// <summary>
	/// The argument name
	/// </summary>
	std::string name = "";

	/// <summary>
	/// The argument type
	/// </summary>
	Value_Type type = Value_Type::UNKNOWN;
	
	/// <summary>
	/// Whether or not the argument has a default value.
	/// </summary>
	bool has_default_value = false;

	/// <summary>
	/// The default value of the argument. Is zero if has_default_value is false.
	/// </summary>
	Value default_value = {};

	/// <summary>
	/// Argument note.
	/// </summary>
	std::string note = "";

	/// <summary>
	/// Default constructor used when first filling in argument data.
	/// </summary>
	Argument() = default;

	/// <summary>
	/// Constructor for arguments without default values.
	/// </summary>
	Argument(const std::string &name, Value_Type type, const std::string &note)
		:name(name), type(type), note(note)
	{
	}

	/// <summary>
	/// Constructor for arguments with string default value.
	/// </summary>
	Argument(const std::string &name, Value_Type type, const std::string &note, const char *default_value)
		: Argument(name, type, note)
	{
		this->has_default_value = true;
		this->default_value.type = Value_Type::STRING;
		strncpy(this->default_value.data.string_value, default_value, sizeof(this->default_value.data.string_value));
	}

	/// <summary>
	/// Constructor for arguments with int default value.
	/// </summary>
	Argument(const std::string &name, Value_Type type, const std::string &note, int default_value)
		: Argument(name, type, note)
	{
		this->has_default_value = true;
		this->default_value.type = Value_Type::INTEGER;
		this->default_value.data.int_value = default_value;
	}

	/// <summary>
	/// Constructor for arguments with float default value.
	/// </summary>
	Argument(const std::string &name, Value_Type type, const std::string &note, float default_value)
		: Argument(name, type, note)
	{
		this->has_default_value = true;
		this->default_value.type = Value_Type::FLOAT;
		this->default_value.data.float_value = default_value;
	}

	/// <summary>
	/// Constructor for arguments with double default value.
	/// </summary>
	Argument(const std::string &name, Value_Type type, const std::string &note, double default_value)
		: Argument(name, type, note)
	{
		this->has_default_value = true;
		this->default_value.type = Value_Type::DOUBLE;
		this->default_value.data.double_value = default_value;
	}

	/// <summary>
	/// Constructor for arguments with bool default value.
	/// </summary>
	Argument(const std::string &name, Value_Type type, const std::string &note, bool default_value)
		: Argument(name, type, note)
	{
		this->has_default_value = true;
		this->default_value.type = Value_Type::BOOLEAN;
		this->default_value.data.bool_value = default_value;
	}
};


/// <summary>
/// The main export from the import process. A simple mapping from function name to the relevant
/// Function_Decl (see \see Function_Decl). 
/// </summary>
using Function_Map = std::unordered_map<std::string, Function_Decl>;


/// <summary>
/// Advances the string_view cursor 'length' characters.
/// </summary>
std::string_view advance(std::string_view source, size_t length)
{
	return source.substr(length);
}

/// <summary>
/// Advances the cursor past all white-space characters.
/// </summary>
std::string_view skip_whitespace(std::string_view source)
{
	if(source.size() == 0)
	{
		return source;
	}

	size_t max_length = source.size();
	size_t length = 0;
	while (length < max_length && std::isspace(source[(int)length]))
	{
		length++;
	}
	return advance(source, length);
}

/// <summary>
/// Parses the first int found in the source string.
/// </summary>
inline size_t get_int(std::string_view source, int &out_result)
{
	size_t max_length = source.size();
	size_t length = 0;
	if (length < max_length && source[0] == '-' || source[0] == '+')
	{
		length++;
	}
	while (length < max_length && std::isdigit(source[length]))
	{
		length++;
	}

	out_result = std::atoi(source.data());

	return length;
}

/// <summary>
/// Parses the first bool found in the source string.
/// </summary>
inline size_t get_bool(std::string_view source, bool &out_result)
{
	size_t length = 0;
	if (source.starts_with("true"))
	{
		length = 4;
		out_result = true;
	}
	else if (source.starts_with("false"))
	{
		length = 5;
		out_result = false;
	}
	if (source.starts_with("1"))
	{
		length = 1;
		out_result = true;
	}
	else if (source.starts_with("0"))
	{
		length = 1;
		out_result = false;
	}

	return length;
}

/// <summary>
/// Parses the quoted string found in the source string. Does NOT include the quotes in out_result!
/// </summary>
inline size_t get_quoted_string(std::string_view source, std::string &out_result)
{
	size_t length = 0;
	if (source[0] != '\"')
	{
		std::cerr << "[ERROR] get_quoted_string() takes a string that start with a quote (after whitespace)" << std::endl;
		return 0;
	}
	length++;

	while (source[length] && source[length] != '\"')
	{
		length++;
	}

	if (source[length] != '\"')
	{
		// We must terminate on a quote if the string is quoted!
		return 0;
	}

	// Add the terminating quote into the length
	length++;

	out_result = std::string(source.begin() + 1, source.begin() + length - 1);

	return length;
}

/// <summary>
/// Parses the first word found in the source string. Word is defined as being delimited by either 
/// space or any non-word character.
/// </summary>
inline size_t get_word_length(std::string_view source)
{
	size_t length = 0;
	while (length < source.size() && source[length] && !std::isspace(source[length]))
	{
		length++;
	}

	return length;
}

/// <summary>
/// Parses the first string found in source. Supports either quoted or unquoted strings.
/// </summary>
inline size_t get_string(std::string_view source, std::string &out_result)
{
	size_t length = 0;

	bool is_quoted = source[length] == '\"';
	if (is_quoted)
	{
		length = get_quoted_string(source, out_result);
	}
	else
	{
		length = get_word_length(source);

		out_result = std::string(source.begin(), source.begin() + length);
	}

	return length;
}

/// <summary>
/// Parses the first symbol found in source. Is almost identical to get_word, except it allows 
/// numbers and specific symbols ('_' and ':') to be included. Technically this would mean that this
/// could allow names that aren't legal C++ symbol names like "123__::__4". However, since that 
/// wouldn't compile anyway, I don't consider that a real issue. 
/// </summary>
inline size_t get_symbol(std::string_view source, std::string &out_result)
{
	size_t max_length = source.size();
	size_t length = 0;
	while (length < max_length && (std::isalnum(source[length]) || source[length] == '_' || source[length] == ':'))
	{
		length++;
	}

	out_result = std::string(source.begin(), source.begin() + length);

	return length;
}

/// <summary>
/// Parses the first double found in the source string.
/// </summary>
inline size_t get_double(std::string_view source, double &out_result)
{
	size_t max_length = source.size();
	size_t total_length = get_word_length(source);
	size_t length = 0;
	bool had_digits = false;

	if (length < max_length && (source[0] == '-' || source[0] == '+'))
	{
		length++;
	}

	while (length < max_length && std::isdigit(source[length]))
	{
		length++;
		had_digits = true;
	}

	// Handle comma separation
	if (length < max_length && source[length] == '.')
	{
		length++;
	}

	while (length < max_length && std::isdigit(source[length]))
	{
		length++;
		had_digits = true;
	}

	// We must have SOME digits. Either '.1' or '1.' is allowed, but not just '.'
	if (!had_digits)
	{
		return false;
	}

	if (length == 0 || length != total_length)
	{
		// We must have used all tokens here!
		return false;
	}

	out_result = std::atof(source.data());

	return length;
}

/// <summary>
/// Parses the first float found in the source string.
/// </summary>
inline size_t get_float(std::string_view source, float &out_result)
{
	size_t max_length = source.size();
	size_t total_length = get_word_length(source);
	size_t length = 0;
	bool had_digits = false;

	if (length < max_length && (source[0] == '-' || source[0] == '+'))
	{
		length++;
	}

	while (length < max_length && std::isdigit(source[length]))
	{
		length++;
		had_digits = true;
	}

	// Handle comma separation
	if (length < max_length && source[length] == '.')
	{
		length++;
	}

	while (length < max_length && std::isdigit(source[length]))
	{
		length++;
		had_digits = true;
	}

	if (length < max_length && source[length] == 'f')
	{
		length++;
	}

	// We must have SOME digits. Either '.1' or '1.' is allowed, but not just '.'
	if (!had_digits)
	{
		return false;
	}

	if (length == 0 || length != total_length)
	{
		// We must have used all tokens here!
		return false;
	}

	double res = std::atof(source.data());
	out_result = (float)res;

	return length;
}


/// <summary>
/// Converts a Value_Type to the C++ equivalent. So STRING -> std::string, BOOL -> bool, etc...
/// </summary>
inline std::string value_type_to_cpp_type(Value_Type type)
{
	switch (type)
	{
	case Value_Type::VOID:
		return "void";
	case Value_Type::STRING:
		return "std::string";
	case Value_Type::INTEGER:
		return "int";
	case Value_Type::FLOAT:
		return "float";
	case Value_Type::DOUBLE:
		return "double";
	case Value_Type::BOOLEAN:
		return "bool";
	}
	return "";
}

/// <summary>
/// Converts a Value_Type to a more readable equivalent. So STRING -> string, BOOL -> bool, etc...
/// </summary>
inline std::string value_type_to_readable_string(Value_Type type)
{
	switch (type)
	{
	case Value_Type::VOID:
		return "void";
	case Value_Type::STRING:
		return "string";
	case Value_Type::INTEGER:
		return "int";
	case Value_Type::FLOAT:
		return "float";
	case Value_Type::DOUBLE:
		return "double";
	case Value_Type::BOOLEAN:
		return "bool";
	}
	return "";
}

/// <summary>
/// Convert a value type to a string containing the Enum literal
/// </summary>
inline std::string to_string(Value_Type type)
{
	switch (type)
	{
	case Value_Type::VOID:
		return "Value_Type::VOID";
	case Value_Type::STRING:
		return "Value_Type::STRING";
	case Value_Type::INTEGER:
		return "Value_Type::INTEGER";
	case Value_Type::FLOAT:
		return "Value_Type::FLOAT";
	case Value_Type::DOUBLE:
		return "Value_Type::DOUBLE";
	case Value_Type::BOOLEAN:
		return "Value_Type::BOOLEAN";
	}
	return "";
}


/// <summary>
/// Convert a value to a string.
/// </summary>
inline std::string to_string(const Value &value)
{
	switch (value.type)
	{
	case Value_Type::VOID:
		return "void";
	case Value_Type::STRING:
		return std::format("\"{}\"", value.data.string_value);
	case Value_Type::INTEGER:
		return std::to_string(value.data.int_value);
	case Value_Type::FLOAT:
		return std::format("{}f", value.data.float_value);
	case Value_Type::DOUBLE:
		return std::format("{}", value.data.double_value);
	case Value_Type::BOOLEAN:
		return value.data.bool_value ? "true" : "false";
	default:
		return "UNKNOWN";
	}
}
